#!/usr/bin/env perl

use strict;
use warnings;
use IO::Handle;
use Getopt::Long;
use Pod::Usage;
use File::Basename;

BEGIN {
	STDERR->autoflush(1);
	STDOUT->autoflush(1);
}

########## functions ##########
sub printTime {
	my $message;
	if (@_ >= 1) {
		($message) = @_;
	} else {
		$message = "Current Time";
	}
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	printf "$message: %4d-%02d-%02d %02d:%02d:%02d\n",$year+1900,$mon+1,$mday,$hour,$min,$sec; 
}

########## options ##########
my ( $help, $man, $DEBUG, $verbose );
my $isHeader;
my $outfilename="";
my $totalOccurFilename="";
my $MinDiffTH=3;
my $NumOfTimes=2;
my $kmerOutFormat='occurNratio';

GetOptions(
		'help|?' => \$help, 
		'man' => \$man,
		'debug' =>\$DEBUG,
		'outHeader' =>\$isHeader,
		'totalOccurFile=s' => \$totalOccurFilename,
		'outfile=s' => \$outfilename,
		'minDiff=i' =>\$MinDiffTH,
		'minFoldChange=f' =>\$NumOfTimes,
		'kmerOutFormat=s' =>\$kmerOutFormat,
		'verbose' =>\$verbose,
	) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(1) if ($kmerOutFormat ne 'meanStd' && $kmerOutFormat ne 'occurNratio');
pod2usage(-verbose => 2) if $man;


########## arguments ##########
if ($kmerOutFormat eq 'occurNratio') {
	pod2usage("***** Error: with kmerOutFormat=occurNratio, exactly 2 input files are required *****") if (@ARGV != 2);
} else {
	pod2usage("***** Error: with kmerOutFormat=meanStd, at least 2 input files are required *****") if (@ARGV < 2);
}

pod2usage("***** Error: Output file must be set *****") if ($outfilename eq "");
pod2usage("***** Error: Total occurrence file which is generated by findTotalOccurrence.sh must be set *****") if ($totalOccurFilename eq "");

######### function: perform the matching kmer, normalisation and print to file. 
###  Values are rounded to the nearest integer during normalisation
my %kmers;
sub performMatch {
	my ($inAdr, $curCol, $denominator, $numerator) = @_;
	my $multiplyRatio = $numerator / $denominator;
	print "Normalisation ratio: $numerator / $denominator = $multiplyRatio\n" if $DEBUG;
	# read through each line
	while (my $line = <$inAdr>) {
		my ($kmer, $occur) = $line=~m/^(\w+)\t(\d+)/;
		print "line $curCol: $kmer\t$occur\n" if $DEBUG;
		# apply normalisation
		$occur = $occur*$multiplyRatio;
		print "Normalised: $curCol: $kmer\t$denominator\t$numerator\t$occur\n" if $DEBUG;
		# round the number to integer
		$occur = int($occur+0.5);
		print "Round: $curCol: $kmer\t$denominator\t$numerator\t$occur\n" if $DEBUG;

		my $value="";
		if (!defined $kmers{$kmer}) {
			# put in a new kmer to %kmers and insert zeroes for previous files
			for (my $i=1; $i<$curCol; $i++) {
				$value.="\t0";
			}
			$kmers{$kmer}="$value\t$occur";
		}
		else {
			$kmers{$kmer}="$kmers{$kmer}\t$occur";
		}
	}
	# patch zero to the kmers which this file does match to 
	for my $key (keys %kmers) {
		my @temp=split("\t", $kmers{$key});
		my $numValue=@temp;
		# the split will return the number of values left after split, 
		#   the first \tValue will get 2 values which the first one is empty
		#   therefore a minus one is needed
		if (($numValue-1)!=$curCol) {
			$kmers{$key}="$kmers{$key}\t0";
		}
	}
}

# Print all the kmers to the output file
sub printHash {
	my ($out, $outHeader, $refKmers) = @_;
	print $outHeader "# Kmer\tReplicate-occurrence\t...\n" if ($isHeader);
	for my $key (keys %$refKmers) {
		print $out "$key$kmers{$key}\n";
	}
}

my $inf=9**9**9;
sub printHashRatio {
	my ($out, $outHeader, $refKmers, $minTH) = @_;
	print $outHeader "# Kmer\tT1-occurrence\tT2-occurrence\tRatio\n" if ($isHeader);
	# only print kmers' occurrence is > threshold to the output file. Additionally, print the ratio
	for my $key (keys %$refKmers) {
		my ($fst, $snd) = $refKmers->{$key} =~ m/^\t(\d+)\t(\d+)/;
		if ( abs($fst-$snd)>=$minTH ) {
			my $fst_x=$fst*$NumOfTimes;
			my $snd_x=$snd*$NumOfTimes;
			if ($fst_x<=$snd || $snd_x<=$fst) {
				my $ratio;
				if ($snd==0) {
					$ratio=$inf;
				} else {
					$ratio = $fst/$snd;
				}
				print $out $key . $refKmers->{$key} . "\t$ratio\n";
			}
		}

	}
}

########## program start ##########

if ($verbose) {
	printTime("Normalise and match kmers starts at");
}

my ($in, $occurIn, $out, $eqExpFH, $outHeader, $file);
open $out, ">", $outfilename || die $!;

if ($isHeader) {
	my $headername="${outfilename}.header";
	open $outHeader, ">", $headername || die $!;
}
open $occurIn, "<", $totalOccurFilename || die $!;


# Reads the total number of occurrence and the maximum for normalisation
my $maxOccur=0;
my %totalOccur;
my $aLine;
while ($aLine=<$occurIn>) {
	last if ($aLine=~/^###/);
	my ($filename,$occur)=$aLine=~m/^(.+)\t(\d+)/;
	my $bname = basename($filename);
	$totalOccur{$bname}=$occur;
}
$aLine=<$occurIn>;
($maxOccur)=$aLine=~/\t(\d+)/;
print "maxOccur: $maxOccur\n" if $DEBUG;


# to record the current input file number
my $curInputFileNum=0;
# Go through each input files
foreach $file (@ARGV) {
	$curInputFileNum++;
	
	printTime("Processing file: $file\n") if ($verbose);
	
	# Open the file
	if (! open($in, "<$file")) {
		print STDERR "Can't open input file $file\n";
		next;
	}

	# It is assume the kmer file is split so the file name would have a .NUM to represent the split file
	my ($name,$path,$suffix) = fileparse($file, qr/\.[^.]*/);
	my $curTotalOccur=$totalOccur{$name};
	if (!defined $curTotalOccur) {
		print STDERR "No total occurrence for $file (without suffix $name is used for comparison) is found in $totalOccurFilename\n";
		next;
	}
	
	# use this function to read through the file and put the kmer and occurrence into the kmer hash
	#   the $curInputFileNum will be used for appending zeros into the newly appeared kmer
	performMatch($in, $curInputFileNum, $curTotalOccur, $maxOccur);
}


if ($kmerOutFormat eq 'meanStd') {
	printHash($out, $outHeader, \%kmers);
} else {
	printHashRatio($out, $outHeader, \%kmers, $MinDiffTH);
}

if ($verbose) {
	printTime("Normalise and match kmers ends at");
}


__DATA__

=head1 NAME

normMatchKmer.pl - This script will match several kmer files into a single one.
  There are two types of kmerOutFormat: meanStd and occurNratio.


=head1 SYNOPSIS

normMatchKmer.pl [-help] [-man] [-debug] [-verbose] -outfile <OUT_FILENAME> -totalOccurFile <TOTAL_OCCURRENCE_FILENAME> 
[-minDiff <INTEGER>] [-minFoldChange <FLOAT>] [-kmerOutFormat <meanStd|occurNratio>] 
[-outHeader] <Kmer_FILE1> [<Kmer_FILE2> ...]

B<Example>

normMatchKmer.pl -kmerOutFormat meanStd -outfile LTE_0_match.tsv -totalOccurFile LTE-N_totalOccur.log LTE_0.uniq.0 LTE_1.uniq.0 LTE_2.uniq.0

normMatchKmer.pl -kmerOutFormat occurNratio -outfile LTE_0_match.tsv -totalOccurFile LTE-N_totalOccur.log -minDiff 4 -minFoldChange 3 POAC_16mer_count.tsv.0 POAT_16mer_count.tsv.0


=head1 OPTIONS

=over 8

=item B<-help>

Print a brief help message and exits.

=item B<-man>

Prints the manual page and exits.

=item B<-debug>

Turn on the script debugging printout.

=item B<-totalOccurFile>

The filename storing the total number of occurrence for each kmer file
and the maximum total number of occurrence.

=item B<-verbose>

Prints progress.

=item B<-outfile>

The output filename

=item B<-minDiff>

Will exclude all kmers with occurrences less than this threshold in both dataset. Default is 3.

=item B<-minFoldChange>

This parameter determines the number of times the occurrences between two sets in order for it to be DEK. Default is 2.

=item B<-outHeader>

Output a header file to show column names.

=item B<-kmerOutFormat>

Accpet values:
  
	meadStd - this output is for analysis containing multiple replicates. It outputs the normalised kmer 
	  occurrences of each file in different columns.
  occurNratio (DEFAULT)- will output exactly 3 columns: 1. occurrence in T1  2. occurrence in T2  
	  3. occurrence ratio (T1/T2).

=back


=head1 DESCRIPTION

This script will take in any number of kmer files which contains two tab seperated columns (# of occurrence and kmer), 
and match their kmers into a master kmer list. Zero occurrence will be inserted to kmers which have no occurrence in one file
but in others


=head1 LICENSE

Copyright (c) 2012 Chon-Kit Kenneth Chan. All rights reserved.

This script is freely available for non-commercial use 
and is covered by the GNU General Public License v3 or later. 
See L<http://www.gnu.org/licenses/gpl.html>

The user of the script agrees to acknowledge the author(s) in any 
scientific publication of results based in part on the use of the script.

=cut

